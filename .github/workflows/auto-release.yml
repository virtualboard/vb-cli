name: Automatic Release

on:
  push:
    branches: [main, dev]
  workflow_dispatch:
    inputs:
      release_type:
        description: "Type of release to create"
        required: true
        default: "auto"
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - rc

env:
  GO_VERSION: "1.25"
  BINARY_NAME: "vb"

jobs:
  determine-release:
    name: Determine Release Type and Version
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      release-type: ${{ steps.check.outputs.release-type }}
      version: ${{ steps.version.outputs.version }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
      tag-name: ${{ steps.version.outputs.tag-name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check if should release
        id: check
        run: |
          # Check if this is a merge to main or dev
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            # Check if this is a merge from dev branch by looking at commit message
            if git log -1 --pretty=%B | grep -Eq "Merge pull request.*from (.+/)?dev"; then
              {
                echo "should-release=true"
                echo "release-type=final"
              } >> "$GITHUB_OUTPUT"
            else
              {
                echo "should-release=false"
                echo "release-type=none"
              } >> "$GITHUB_OUTPUT"
            fi
          elif [[ "${{ github.ref_name }}" == "dev" ]]; then
            # Commented out: Only release when merging to main, not on dev pushes
            # {
            #   echo "should-release=true"
            #   echo "release-type=rc"
            # } >> "$GITHUB_OUTPUT"
            {
              echo "should-release=false"
              echo "release-type=none"
            } >> "$GITHUB_OUTPUT"
          else
            {
              echo "should-release=false"
              echo "release-type=none"
            } >> "$GITHUB_OUTPUT"
          fi

      - name: Get current version
        id: current-version
        run: |
          # Get version from code (more reliable than git tags)
          CURRENT_VERSION=$(grep 'const Current = ' internal/version/version.go | sed 's/.*"\(.*\)".*/\1/')
          echo "current-version=$CURRENT_VERSION" >> "$GITHUB_OUTPUT"
          echo "Current version from code: $CURRENT_VERSION"

      - name: Calculate new version
        id: version
        run: |
          CURRENT_VERSION="${{ steps.current-version.outputs.current-version }}"
          MANUAL_TYPE="${{ github.event.inputs.release_type }}"

          # Use the version from code directly - no calculation needed
          NEW_VERSION="$CURRENT_VERSION"

          # Determine if this should be a prerelease based on version suffix
          if [[ "$CURRENT_VERSION" =~ -rc ]]; then
            IS_PRERELEASE="true"
          else
            IS_PRERELEASE="false"
          fi

          # For manual releases, we could add logic to modify the version if needed
          # but for now, we'll use the code version as-is
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            case "$MANUAL_TYPE" in
              "auto")
                # Use the code version as-is
                ;;
              "patch"|"minor"|"major"|"rc")
                echo "Manual version bumping not implemented - using code version: $CURRENT_VERSION"
                echo "To change version, update internal/version/version.go and commit"
                ;;
            esac
          fi

          # Check if tag already exists and warn
          if git rev-parse "$NEW_VERSION" >/dev/null 2>&1; then
            echo "âš ï¸  Tag $NEW_VERSION already exists - will be replaced"
            echo "This usually means the code version was updated but the tag wasn't"
          fi

          {
            echo "version=$NEW_VERSION"
            echo "is-prerelease=$IS_PRERELEASE"
            echo "tag-name=$NEW_VERSION"
          } >> "$GITHUB_OUTPUT"
          echo "Using version from code: $NEW_VERSION (prerelease: $IS_PRERELEASE)"

  test:
    name: Test and Scan
    needs: determine-release
    if: needs.determine-release.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Run tests with coverage
        run: make test

      - name: Run security scan
        run: make scan

      - name: Upload coverage reports
        uses: codecov/codecov-action@v5
        if: success()
        with:
          files: ./coverage.out
          flags: unittests
          name: codecov-umbrella

  build:
    name: Build for all platforms
    needs: [determine-release, test]
    if: needs.determine-release.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
            platform: linux-amd64
          - goos: linux
            goarch: arm64
            platform: linux-arm64
          - goos: darwin
            goarch: amd64
            platform: macos-amd64
          - goos: darwin
            goarch: arm64
            platform: macos-arm64
          - goos: windows
            goarch: amd64
            platform: windows-amd64

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Verify version file
        run: |
          VERSION="${{ needs.determine-release.outputs.version }}"
          echo "Using version from code: $VERSION"

          # Verify the version file matches what we expect
          CURRENT_VERSION=$(grep 'const Current = ' internal/version/version.go | sed 's/.*"\(.*\)".*/\1/')
          if [[ "$CURRENT_VERSION" == "$VERSION" ]]; then
            echo "âœ… Version file matches expected version: $VERSION"
          else
            echo "âŒ Version mismatch: expected $VERSION, found $CURRENT_VERSION"
            exit 1
          fi

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          mkdir -p dist
          go build -ldflags="-s -w -X main.version=${{ needs.determine-release.outputs.version }}" -o dist/${{ env.BINARY_NAME }}-${{ matrix.platform }} .

      - name: Upload build artifacts
        uses: actions/upload-artifact@v5
        with:
          name: ${{ env.BINARY_NAME }}-${{ matrix.platform }}
          path: dist/${{ env.BINARY_NAME }}-${{ matrix.platform }}

  release:
    name: Create Release
    needs: [determine-release, build]
    if: needs.determine-release.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v6

      - name: Prepare release assets
        run: |
          mkdir -p release-assets

          # Debug: List all files and directories
          echo "Current directory contents:"
          ls -la
          echo "Looking for artifacts..."

          # Process each artifact directory
          for artifact_dir in ${{ env.BINARY_NAME }}-*; do
            if [ -d "$artifact_dir" ]; then
              echo "Processing artifact directory: $artifact_dir"

              # Extract platform from directory name (e.g., vb-linux-amd64 -> linux-amd64)
              platform=${artifact_dir#${{ env.BINARY_NAME }}-}

              # The binary file should be directly in the artifact directory
              binary_file="$artifact_dir/${{ env.BINARY_NAME }}-$platform"

              if [ -f "$binary_file" ]; then
                echo "Found binary: $binary_file"

                # Add .exe extension for Windows and copy to release-assets
                if [[ "$platform" == *"windows"* ]]; then
                  cp "$binary_file" "release-assets/${{ env.BINARY_NAME }}-$platform.exe"
                  echo "Created: ${{ env.BINARY_NAME }}-$platform.exe"
                else
                  # Copy binary directly for Unix-like systems
                  cp "$binary_file" "release-assets/${{ env.BINARY_NAME }}-$platform"
                  echo "Created: ${{ env.BINARY_NAME }}-$platform"
                fi
              else
                echo "No binary file found at $binary_file"
                # List contents for debugging
                echo "Contents of $artifact_dir:"
                ls -la "$artifact_dir"
              fi
            fi
          done

          # Debug: List release-assets directory
          echo "Release assets directory contents:"
          ls -la release-assets/

          # Verify we have the expected files
          echo "Checking for expected binary files:"
          for platform in linux-amd64 linux-arm64 macos-amd64 macos-arm64 windows-amd64; do
            if [[ "$platform" == *"windows"* ]]; then
              if [ -f "release-assets/${{ env.BINARY_NAME }}-$platform.exe" ]; then
                echo "âœ“ Found ${{ env.BINARY_NAME }}-$platform.exe"
              else
                echo "âœ— Missing ${{ env.BINARY_NAME }}-$platform.exe"
              fi
            else
              if [ -f "release-assets/${{ env.BINARY_NAME }}-$platform" ]; then
                echo "âœ“ Found ${{ env.BINARY_NAME }}-$platform"
              else
                echo "âœ— Missing ${{ env.BINARY_NAME }}-$platform"
              fi
            fi
          done

          # Create checksums only if there are files
          cd release-assets
          if [ "$(ls -A .)" ]; then
            sha256sum ./* > checksums.txt
            echo "Created checksums.txt"
            cat checksums.txt
          else
            echo "No files found in release-assets directory"
            exit 1
          fi
          cd ..

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ needs.determine-release.outputs.version }}"
          RELEASE_TYPE="${{ needs.determine-release.outputs.release-type }}"

          # Generate changelog from git commits since last tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s" "$PREVIOUS_TAG"..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s" --max-count=10)
          fi

          # Create release notes
          if [[ "$RELEASE_TYPE" == "rc" ]]; then
            TITLE="Release Candidate $VERSION"
            DESCRIPTION="This is a release candidate for testing purposes. Please test thoroughly before using in production."
          else
            TITLE="Release $VERSION"
            DESCRIPTION="This is a stable release ready for production use."
          fi

          cat > release-notes.md << EOF
          ## $TITLE

          $DESCRIPTION

          ### Changes

          $CHANGELOG

          ### Installation

          Download the appropriate binary for your platform:

          - **Linux AMD64**: \`${{ env.BINARY_NAME }}-linux-amd64\`
          - **Linux ARM64**: \`${{ env.BINARY_NAME }}-linux-arm64\`
          - **macOS AMD64**: \`${{ env.BINARY_NAME }}-macos-amd64\`
          - **macOS ARM64**: \`${{ env.BINARY_NAME }}-macos-arm64\`
          - **Windows AMD64**: \`${{ env.BINARY_NAME }}-windows-amd64.exe\`

          ### Verification

          Verify the integrity of downloaded files using the provided checksums:

          \`\`\`bash
          sha256sum -c checksums.txt
          \`\`\`
          EOF

          {
            echo "title=$TITLE"
            echo "changelog<<EOF"
            cat release-notes.md
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Verify version consistency
        run: |
          echo "Verifying version consistency between code and release"
          echo "Code version: $(grep 'const Current = ' internal/version/version.go | sed 's/.*"\(.*\)".*/\1/')"
          echo "Release version: ${{ needs.determine-release.outputs.version }}"

      - name: Create Git Tag
        run: |
          echo "Attempting to create tag: ${{ needs.determine-release.outputs.tag-name }}"

          # Delete existing tag if it exists (both local and remote)
          if git rev-parse "${{ needs.determine-release.outputs.tag-name }}" >/dev/null 2>&1; then
            echo "ðŸ—‘ï¸  Deleting existing tag: ${{ needs.determine-release.outputs.tag-name }}"
            git tag -d "${{ needs.determine-release.outputs.tag-name }}" || true
            git push origin ":refs/tags/${{ needs.determine-release.outputs.tag-name }}" || true
          fi

          # Create and push the tag
          if git tag -a "${{ needs.determine-release.outputs.tag-name }}" -m "Release ${{ needs.determine-release.outputs.tag-name }}" && git push origin "${{ needs.determine-release.outputs.tag-name }}"; then
            echo "âœ… Tag created and pushed successfully"
          else
            echo "âŒ Failed to create/push tag"
            echo "Error details:"
            echo "Repository: ${{ github.repository }}"
            echo "Organization: ${{ github.repository_owner }}"
            echo ""
            echo "Possible causes:"
            echo "1. Organization-level rulesets blocking tag creation"
            echo "2. Insufficient permissions for GITHUB_TOKEN"
            echo "3. Branch protection rules affecting ref creation"
            echo ""
            echo "Solutions:"
            echo "1. Check organization rulesets: https://github.com/${{ github.repository_owner }}/settings"
            echo "2. Check repository settings: https://github.com/${{ github.repository }}/settings"
            echo "3. Create tag manually: git tag ${{ needs.determine-release.outputs.tag-name }} && git push origin ${{ needs.determine-release.outputs.tag-name }}"
            echo ""
            echo "The release will continue without the git tag..."
          fi

      - name: Create Release
        id: create-release
        uses: softprops/action-gh-release@v2
        continue-on-error: true
        with:
          tag_name: ${{ needs.determine-release.outputs.tag-name }}
          name: ${{ steps.changelog.outputs.title }}
          body: ${{ steps.changelog.outputs.changelog }}
          files: |
            release-assets/*
          draft: false
          prerelease: ${{ needs.determine-release.outputs.is-prerelease }}
          generate_release_notes: true
          make_latest: ${{ needs.determine-release.outputs.release-type == 'final' }}

      - name: Upload Release Assets as Artifacts
        if: steps.create-release.outcome == 'failure'
        uses: actions/upload-artifact@v5
        with:
          name: release-assets-${{ needs.determine-release.outputs.tag-name }}
          path: release-assets/
          retention-days: 30

      - name: Handle Release Creation Failure
        if: steps.create-release.outcome == 'failure'
        run: |
          echo "âŒ Release creation failed due to repository rules or existing tag"
          echo "This is likely due to:"
          echo "1. Repository rules blocking tag/release creation"
          echo "2. Tag ${{ needs.determine-release.outputs.tag-name }} already exists"
          echo ""
          echo "The workflow will continue, but no release will be created."
          echo "Release assets have been uploaded as workflow artifacts for manual release."
          echo ""
          echo "You may need to:"
          echo "1. Check organization rulesets: https://github.com/${{ github.repository_owner }}/settings"
          echo "2. Delete existing tag: git tag -d ${{ needs.determine-release.outputs.tag-name }} && git push origin --delete ${{ needs.determine-release.outputs.tag-name }}"
          echo "3. Download the release assets from the workflow artifacts and create release manually"

  # homebrew:
  #   name: Update Homebrew Formula
  #   needs: [determine-release, release]
  #   if: needs.determine-release.outputs.should-release == 'true' && needs.determine-release.outputs.release-type == 'final'
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout homebrew-tap
  #       uses: actions/checkout@v6
  #       with:
  #         repository: ${{ github.repository_owner }}/homebrew-tap
  #         token: ${{ secrets.GITHUB_TOKEN }}
  #         path: homebrew-tap

  #     - name: Update formula
  #       run: |
  #         VERSION="${{ needs.determine-release.outputs.version }}"
  #         BINARY_NAME="${{ env.BINARY_NAME }}"

  #         # Download the macOS ARM64 binary to calculate SHA256
  #         curl -L -o "$BINARY_NAME-macos-arm64" "https://github.com/${{ github.repository }}/releases/download/$VERSION/$BINARY_NAME-macos-arm64"
  #         SHA256=$(sha256sum "$BINARY_NAME-macos-arm64" | cut -d' ' -f1)

  #         # Create or update the formula
  #         cat > homebrew-tap/Formula/$BINARY_NAME.rb << EOF
  #         class Vb < Formula
  #           desc "Virtual Board CLI - A command-line tool for managing virtual boards"
  #           homepage "https://github.com/${{ github.repository }}"
  #           url "https://github.com/${{ github.repository }}/archive/$VERSION.tar.gz"
  #           sha256 "$SHA256"
  #           license "MIT"

  #           depends_on "go" => :build

  #           def install
  #             system "go", "build", *std_go_args(ldflags: "-s -w -X main.version=$VERSION"), "."
  #           end

  #           test do
  #             system "\#{bin}/$BINARY_NAME", "version"
  #           end
  #         end
  #         EOF

  #     - name: Commit and push changes
  #       run: |
  #         cd homebrew-tap
  #         git config --local user.email "action@github.com"
  #         git config --local user.name "GitHub Action"
  #         git add .
  #         git diff --staged --quiet || git commit -m "Update ${{ env.BINARY_NAME }} to ${{ needs.determine-release.outputs.version }}"
  #         git push
